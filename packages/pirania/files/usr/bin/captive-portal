#!/bin/sh
# requires nftables, liblucihttp0, liblucihttp-lua, uhttpd, uhttpd-mod-lua, uhttpd-mod-ubus


clean_tables () {
	echo "Cleaning captive-portal rules if there's any"
	if nft list tables inet | grep -q "pirania"; then
		nft delete table inet pirania
	fi

	#echo "Flushing rules"
		#nft flush chain inet pirania prerouting
		#nft flush chain inet pirania input
		#nft flush chain inet pirania forward
	
}

# Not needed anymore, since we are using nft set
#clean_sets () {
#	echo "Cleaning ipset lists"
#	ipset flush pirania-auth-macs
#	ipset flush pirania-allowlist-ipv4
#	ipset flush pirania-allowlist-ipv6
#}

set_nftables () { 
	echo "Apply captive-portal rules"
	# Detect wheter add or insert rules
	append_nft_rules=$(uci get pirania.base_config.append_nft_rules 2> /dev/null)
	if [ "$append_nft_rules" = "1" ] ; then
		op="add rule"
	else
		op="insert rule"
	fi

	# Create pirania tables	
	nft create table inet pirania
	# Create default tables and chains
	nft add table inet pirania
	nft add chain inet pirania prerouting { type nat hook prerouting priority 0 \; }
	nft add chain inet pirania input { type filter hook input priority 0 \; }
	nft add chain inet pirania forward { type filter hook forward priority 0 \; }

	# Only accept packets from bridged interfaces - check this out after
    #for interface in $(uci get pirania.base_config.catch_bridged_interfaces); do
	#	 nft insert rule inet pirania prerouting iifname $interface accept
    #done
	# stop processing the chain for authorized macs and allowed ips (so they are accepted)
	nft $op inet pirania prerouting ether saddr @pirania-auth-macs accept
	nft $op inet pirania prerouting ip 	  daddr @pirania-allowlist-ipv4 accept
	nft $op inet pirania prerouting ip6   daddr @pirania-allowlist-ipv6 accept


	nft $op inet pirania prerouting meta l4proto udp udp dport 53 ip saddr @pirania-allowlist-ipv4 counter log prefix "ipv4DNS request from LAN: " redirect to :59053
	nft $op inet pirania prerouting meta l4proto udp udp dport 53 ip6 saddr @pirania-allowlist-ipv6 counter log prefix "ipv6DNS request from LAN: " redirect to :59053
	nft $op inet pirania prerouting meta l4proto udp udp dport 53 ether saddr @pirania-auth-macs counter log prefix "SMACDNS request from LAN: " redirect to :59053


	nft $op inet pirania prerouting meta l4proto tcp tcp dport 80 ether saddr != @pirania-auth-macs counter log prefix "SMAC80 request from LAN: " redirect to :59080
	nft $op inet pirania prerouting meta l4proto tcp tcp dport 80 ip saddr != @pirania-allowlist-ipv4 counter log prefix "ipv4HTTP request from LAN: " redirect to :59080
	nft $op inet pirania prerouting meta l4proto tcp tcp dport 80 ip6 saddr != @pirania-allowlist-ipv6 counter log prefix "ipv6HTTP request from LAN: " redirect to :59080



	# And in there let's reject them with the best suited reject reason.
	# Needed to change its value because of this error:
	# Error: Prefix length 255 is invalid for type of 32 bits width
    # add rule inet pirania forward meta mark 0x66/0xff counter reject with tcp reset

	nft $op inet pirania forward meta mark 0x11/0x11 counter reject with tcp reset
	nft $op inet pirania forward meta mark 0x11/0x11 counter reject
}

update_ipsets () {

  # Create tables and sets
  echo "Updating captive-portal rules"

  # Add mac-adress set
  nft add set inet pirania pirania-auth-macs { type ether_addr\; }
  # Add authorized MAC addresses
  for mac in $(pirania_authorized_macs) ; do
    nft add element inet pirania pirania-auth-macs {$mac}
  done

  # Create ipv4 set on pirania table
  nft add set inet pirania pirania-allowlist-ipv4 { type ipv4_addr \; flags interval \; comment \"allow ipv4 list\" \; }
  # Create ipv6 set on pirania table
  nft add set inet pirania pirania-allowlist-ipv6 { type ipv6_addr \; flags interval \; comment \"allow ipv6 list\" \; }

  # Update pirania-allowlist sets for ipv4 and ipv6
  for ipvX in ipv4 ipv6 ; do
 # Don't need this if, since addr type is specified in 'type ipv6_addr'
 #   if [ "$ipvX" = "ipv4" ] ; then
 #     family=inet
 #   else
 #     family=inet6
 #   fi

    # Clear existing entries (optional)
	nft flush set inet pirania pirania-allowlist-${ipvX}

    # Add allowed IP addresses/prefixes
    for item in $(uci get pirania.base_config.allowlist_$ipvX); do
      nft add element inet pirania pirania-allowlist-${ipvX} {$item}
    done
  done
}

#update_ipsets () {
	# using temporary ipset sets and swaping them so the update
	# implies minimal disturb to the network and a previous clean-up
	# is not needed
#	ipset -exist create pirania-auth-macs hash:mac timeout 0
#	ipset -exist create pirania-auth-macs-tmp hash:mac timeout 0
#	for mac in $(pirania_authorized_macs) ; do
#		ipset -exist add pirania-auth-macs-tmp $mac
#	done
#	ipset swap pirania-auth-macs-tmp pirania-auth-macs
#	ipset destroy pirania-auth-macs-tmp
#
#	for ipvX in ipv4 ipv6 ; do
#		if [ "$ipvX" = "ipv4" ] ; then
#			family=inet
#		else
#			family=inet6
#		fi
#		ipset -exist create pirania-allowlist-${ipvX} hash:net family $family
#		ipset -exist create pirania-allowlist-${ipvX}-tmp hash:net family $family
#		for item in $(uci get pirania.base_config.allowlist_$ipvX); do
#			ipset -exist add pirania-allowlist-${ipvX}-tmp $item
#		done
#		ipset swap pirania-allowlist-${ipvX}-tmp pirania-allowlist-${ipvX}
#		ipset destroy pirania-allowlist-${ipvX}-tmp
#	done
#}

# check if captive-portal is enabled in /etc/config/pirania
enabled=$(uci get pirania.base_config.enabled)

if  [ "$1" = "start" ]; then
	echo "Running captive-portal"
	clean_tables
	update_ipsets
	set_nftables
	exit
elif [ "$1" = "update" ] ; then
	update_ipsets
	exit
elif [ "$1" = "clean" ] || [ "$1" = "stop" ] ; then
	clean_tables
	exit
elif [ "$enabled" = "1" ]; then
	clean_tables
	update_ipsets
	set_nftables
	exit
else
	echo "Pirania captive-portal is disabled. Try running captive-portal start"
	exit
fi
